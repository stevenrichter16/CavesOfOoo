<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Enhanced Adventure Roguelike</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { 
    --bg:#0b0b0f; --fg:#c9ffd6; --dim:#86b99a; --accent:#ffd27f; 
    --danger:#ff6b6b; --ok:#7effa0; --overlay:#0b0b0fcc;
    --xp:#b19cd9; --magic:#87ceeb; --rare:#ff69b4;
  }
  html,body{height:100%}
  body{
    margin:0;padding:16px;background:var(--bg);color:var(--fg);
    font-family:ui-monospace,Menlo,Consolas,monospace;display:grid;gap:12px;
    grid-template-rows:auto auto 1fr auto;
  }
  h1{margin:0 0 6px 0;font-size:18px;color:var(--accent)}
  #hud{display:flex;gap:16px;flex-wrap:wrap;align-items:center}
  .pill{padding:6px 10px;border:1px solid #2c2f33;border-radius:999px;color:var(--dim)}
  .pill.active{border-color:var(--accent);color:var(--accent)}
  #game{
    white-space:pre;line-height:1.05;font-size:16px;
    position:relative;
  }
  #legend{color:var(--dim);font-size:13px}
  #log{border-top:1px solid #1c1f22;padding-top:8px;max-height:30vh;overflow:auto;font-size:13px}
  .good{color:var(--ok)} .bad{color:var(--danger)} .note{color:var(--accent)}
  .xp{color:var(--xp)} .magic{color:var(--magic)} .rare{color:var(--rare)}
  a.button, button.button{
    color:var(--bg);background:var(--accent);padding:6px 10px;
    border-radius:8px;text-decoration:none;font-weight:700;border:none;cursor:pointer;
  }
  
  /* Inventory overlay */
  #overlay {
    display:none; position:fixed; inset:0; background:var(--overlay);
    align-items:center; justify-content:center; z-index:1000;
  }
  #overlay .panel {
    background:#121418; border:1px solid #2c2f33; border-radius:10px; 
    padding:14px 16px; min-width:400px; max-width:600px;
    box-shadow:0 10px 40px rgba(0,0,0,0.5);
    max-height:80vh; overflow-y:auto;
  }
  #overlay h2 { margin:0 0 12px 0; font-size:16px; color:var(--accent); }
  #overlay .item { 
    display:flex; justify-content:space-between; gap:8px; 
    padding:4px 8px; margin:2px 0; border-radius:4px;
    cursor:pointer; transition:background 0.2s;
  }
  #overlay .item:hover { background:#1a1d22; }
  #overlay .item.selected { background:#2a2d32; border:1px solid var(--accent); }
  #overlay .item .name { font-weight:600; }
  #overlay .item .desc { color:var(--dim); font-size:12px; }
  #overlay .hint { margin-top:12px; padding-top:8px; border-top:1px solid #2c2f33; color:var(--dim); font-size:12px; }
  .equipped { color:var(--ok); }
  
  /* Combat animation */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-2px); }
    75% { transform: translateX(2px); }
  }
  .shake { animation: shake 0.2s; }
  
  /* Floating damage numbers */
  .damage-float {
    position:absolute; color:var(--danger); font-weight:bold;
    animation: float-up 1s ease-out forwards; pointer-events:none;
    text-shadow: 0 0 3px rgba(0,0,0,0.8);
  }
  @keyframes float-up {
    0% { transform: translateY(0); opacity:1; }
    100% { transform: translateY(-30px); opacity:0; }
  }
  
  /* Status effects bar */
  #statusBar {
    display:flex; gap:8px; flex-wrap:wrap; margin-top:4px;
  }
  .status-effect {
    padding:3px 6px; border-radius:4px; font-size:11px;
    background:#1a1d22; border:1px solid #2c2f33;
  }
  .status-effect.buff { border-color:var(--ok); color:var(--ok); }
  .status-effect.debuff { border-color:var(--danger); color:var(--danger); }
</style>
</head>
<body>
  <div>
    <h1>Enhanced Adventure Roguelike — Ooo Explorer v2.0</h1>
    <div id="legend">
      <strong>Legend:</strong>
      <span class="pill">@ you</span>
      <span class="pill">g goober</span><span class="pill">i ice-thing</span>
      <span class="pill">s sootling</span><span class="pill">f firefly</span>
      <span class="pill">B boss</span>
      <span class="pill">★ artifact</span><span class="pill">♪ oddity</span>
      <span class="pill">! potion</span><span class="pill">/ weapon</span>
      <span class="pill">] armor</span><span class="pill">$ chest</span>
      <span class="pill">▲ shrine</span><span class="pill">+ door</span>
    </div>
  </div>
  <div id="hud">
    <div class="pill" id="hp">HP</div>
    <div class="pill" id="xp">XP</div>
    <div class="pill" id="level">Level</div>
    <div class="pill" id="str">STR</div>
    <div class="pill" id="def">DEF</div>
    <div class="pill" id="weapon">Weapon</div>
    <div class="pill" id="armor">Armor</div>
    <div class="pill" id="potions">Potions</div>
    <div class="pill" id="time">Time</div>
    <div class="pill" id="biome">Biome</div>
    <div class="pill" id="coords">Area</div>
    <div id="statusBar"></div>
  </div>
  <div style="position:relative">
    <div id="game"></div>
  </div>
  <div id="logger" class="log"></div>
  <div id="log"></div>
  <div style="display:flex;gap:8px">
    <a href="#" id="restart" class="button" style="display:none">Restart</a>
    <button id="resetWorld" class="button" title="Clear saved world">Reset World</button>
    <button id="help" class="button">Help</button>
  </div>

  <!-- Inventory overlay -->
  <div id="overlay">
    <div class="panel">
      <h2 id="overlayTitle">Inventory</h2>
      <div id="overlayContent"></div>
      <div class="hint" id="overlayHint">Arrow keys to select • Enter to use/equip • D to drop • I/Esc to close</div>
    </div>
  </div>

<script>
/* ========== Configuration & Constants ========== */
const W=48, H=22;
const TILE = { 
  wall:"#", floor:".", player:"@", artifact:"★", oddity:"♪",
  potion:"!", weapon:"/", armor:"]", chest:"$", shrine:"▲", door:"+",
  monsters:{ goober:"g", icething:"i", sootling:"s", firefly:"f", boss:"B" }
};

const BIOMES = [
  { id:"candy_forest", color:"#ff69b4", monsters:["goober","sootling"] },
  { id:"frost_caverns", color:"#87ceeb", monsters:["icething","firefly"] },
  { id:"volcanic_marsh", color:"#ff6347", monsters:["sootling","goober"] },
  { id:"glimmering_meadows", color:"#9370db", monsters:["firefly","icething"] },
];

const WEAPONS = [
  { name:"Grass Sword", dmg:3, desc:"A blade of living grass" },
  { name:"Bacon Sword", dmg:4, desc:"Sizzles with greasy power" },
  { name:"Root Sword", dmg:5, desc:"Ancient and gnarled" },
  { name:"Crystal Sword", dmg:6, desc:"Refracts light and enemies" },
  { name:"Demon Sword", dmg:8, desc:"Whispers dark algebraic truths" },
];

const ARMORS = [
  { name:"Sweater", def:1, desc:"Cozy and protective" },
  { name:"Tin Armor", def:2, desc:"Rattles reassuringly" },
  { name:"Ice Armor", def:3, desc:"Cool to the touch" },
  { name:"Jake Suit", def:4, desc:"Stretchy and durable" },
  { name:"Cosmic Armor", def:5, desc:"Woven from starlight" },
];

const POTIONS = [
  { name:"Red Potion", effect:"heal", value:12, turns:0, desc:"Tastes like strawberries (+12 HP)" },
  { name:"Blue Potion", effect:"max_heal", value:999, turns:0, desc:"Fizzy and electric (Full heal)" },
  { name:"Green Potion", effect:"buff_str", value:4, turns:25, desc:"Smells like fresh grass (+4 STR)" },
  { name:"Purple Potion", effect:"buff_def", value:4, turns:25, desc:"Thick and syrupy (+4 DEF)" },
  { name:"Yellow Potion", effect:"buff_both", value:2, turns:30, desc:"Bubbles with energy (+2 STR/DEF)" },
  { name:"Black Potion", effect:"berserk", value:6, turns:15, desc:"Bitter medicine (+6 STR, -2 DEF)" },
];

const QUOTES = {
  candy_forest:{ 
    dusk:{ rainy:["Raindrops gather on sugar petals like tears we sometimes swallow silently."] },
    shrine:["The Candy People left this shrine. It smells like birthday cake and nostalgia."]
  },
  frost_caverns:{ 
    night:{ clear:["Frosted edges catch the dying light and whisper, we still shine."] },
    shrine:["An Ice King shrine. The inscription reads: 'Gunter was here'."]
  },
  volcanic_marsh:{ 
    noon:{ clear:["The molten river pulses like a loud heart daring you to feel alive."] },
    shrine:["A Fire Kingdom seal marks this ancient shrine. It's warm to the touch."]
  },
  glimmering_meadows:{ 
    evening:{ clear:["Fireflies hum a lullaby of a hundred lights, inviting you to rest."] },
    shrine:["Marceline carved something here long ago. The words have faded but the feeling remains."]
  },
};

const TIMES = ["dawn","morning","noon","afternoon","evening","dusk","night"];
const WEATHERS = ["clear","rainy","windy","snowy","stormy"];

/* ========== Helpers & RNG ========== */
const rnd = n => Math.floor(Math.random()*n);
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const choice = arr => arr[rnd(arr.length)];
function roll(min,max){ return min + Math.floor(Math.random()*(max-min+1)); }

function mulberry32(a){ 
  return function(){ 
    let t = a += 0x6D2B79F5; 
    t = Math.imul(t ^ t>>>15, t | 1);
    t ^= t + Math.imul(t ^ t>>>7, t | 61); 
    return ((t ^ t>>>14) >>> 0) / 4294967296; 
  }; 
}

function seededRand(seed){ 
  const f = mulberry32(seed>>>0); 
  return { 
    next: f, 
    int:n=>Math.floor(f()*n), 
    pick:arr=>arr[Math.floor(f()*arr.length)],
    between:(min,max)=>min+Math.floor(f()*(max-min+1))
  }; 
}

function hashStr(s){ 
  let h=2166136261>>>0; 
  for(let i=0;i<s.length;i++){ 
    h ^= s.charCodeAt(i); 
    h = Math.imul(h,16777619); 
  } 
  return h>>>0; 
}

function esc(s){ return s.replace(/[&<>]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
function dist(x1,y1,x2,y2){ return Math.abs(x1-x2) + Math.abs(y1-y2); }

/* ========== Persistence ========== */
const STORE_PREFIX = "ooo_enhanced_v1";
function chunkKey(seed,cx,cy){ return `${STORE_PREFIX}:${seed}:${cx}:${cy}`; }
function saveChunk(seed,cx,cy,chunk){ 
  try{ localStorage.setItem(chunkKey(seed,cx,cy), JSON.stringify(chunk)); }catch(e){} 
}
function loadChunk(seed,cx,cy){ 
  const raw = localStorage.getItem(chunkKey(seed,cx,cy)); 
  return raw ? JSON.parse(raw) : null; 
}
function clearWorld(){ 
  Object.keys(localStorage).filter(k=>k.startsWith(STORE_PREFIX+":")).forEach(k=>localStorage.removeItem(k)); 
}

/* ========== Dungeon Generation ========== */
function generateRooms(sr, count=5){
  const rooms = [];
  for(let i=0; i<count; i++){
    const w = sr.between(4,10);
    const h = sr.between(4,8);
    const x = sr.between(0, Math.max(1, W-w));
    const y = sr.between(0, Math.max(1, H-h));
    rooms.push({x,y,w,h});
  }
  return rooms;
}

function carveRoom(map, room){
  for(let y=room.y; y<room.y+room.h; y++){
    for(let x=room.x; x<room.x+room.w; x++){
      if(y>=0 && y<H && x>=0 && x<W) map[y][x] = ".";
    }
  }
}

function carveCorridor(map, x1,y1, x2,y2){
  while(x1 !== x2 || y1 !== y2){
    if(y1>=0 && y1<H && x1>=0 && x1<W) map[y1][x1] = ".";
    if(x1 < x2) x1++;
    else if(x1 > x2) x1--;
    else if(y1 < y2) y1++;
    else if(y1 > y2) y1--;
  }
  if(y2>=0 && y2<H && x2>=0 && x2<W) map[y2][x2] = ".";
}

function ensureEdgeExits(map, sr) {
  const gatesPerSide = () => 1 + sr.int(2);
  // Create exits on each edge
  for(let side=0; side<4; side++){
    for(let g=0; g<gatesPerSide(); g++){
      if(side===0){ // Left
        const y = 1 + sr.int(H-2);
        if(y>=0 && y<H) {
          map[y][0]=".";
          for(let x=1;x<5 && x<W-1;x++) {
            if(y>=0 && y<H && x>=0 && x<W) map[y][x]=".";
          }
        }
      } else if(side===1){ // Right
        const y = 1 + sr.int(H-2);
        if(y>=0 && y<H) {
          map[y][W-1]=".";
          for(let x=W-2;x>W-6 && x>0;x--) {
            if(y>=0 && y<H && x>=0 && x<W) map[y][x]=".";
          }
        }
      } else if(side===2){ // Top
        const x = 1 + sr.int(W-2);
        if(x>=0 && x<W) {
          map[0][x]=".";
          for(let y=1;y<5 && y<H-1;y++) {
            if(y>=0 && y<H && x>=0 && x<W) map[y][x]=".";
          }
        }
      } else { // Bottom
        const x = 1 + sr.int(W-2);
        if(x>=0 && x<W) {
          map[H-1][x]=".";
          for(let y=H-2;y>H-6 && y>0;y--) {
            if(y>=0 && y<H && x>=0 && x<W) map[y][x]=".";
          }
        }
      }
    }
  }
}

function findFloorTile(map, sr){
  for(let tries=0;tries<1000;tries++){
    const x = sr.int(W), y = sr.int(H);
    if(map[y][x]===".") return {x,y};
  }
  return null;
}

function placeItems(map, sr, biome){
  const items = [];
  
  // Place chests
  for(let i=0; i<sr.between(1,3); i++){
    const pos = findFloorTile(map, sr);
    if(pos) {
      map[pos.y][pos.x] = "$";
      items.push({type:"chest", x:pos.x, y:pos.y, opened:false});
    }
  }
  
  // Place shrines (rare)
  if(sr.next() < 0.3){
    const pos = findFloorTile(map, sr);
    if(pos) {
      map[pos.y][pos.x] = "▲";
      items.push({type:"shrine", x:pos.x, y:pos.y, used:false});
    }
  }
  
  // Place artifacts and oddities
  for(let i=0; i<sr.between(2,5); i++){
    const pos = findFloorTile(map, sr);
    if(pos) map[pos.y][pos.x] = sr.pick(["★","♪"]);
  }
  
  // Place potions
  for(let i=0; i<sr.between(1,3); i++){
    const pos = findFloorTile(map, sr);
    if(pos) {
      map[pos.y][pos.x] = "!";
      items.push({
        type:"potion", x:pos.x, y:pos.y,
        item: sr.pick(POTIONS)
      });
    }
  }
  
  // Chance for weapon/armor
  if(sr.next() < 0.4){
    const pos = findFloorTile(map, sr);
    if(pos) {
      const isWeapon = sr.next() < 0.5;
      map[pos.y][pos.x] = isWeapon ? "/" : "]";
      items.push({
        type: isWeapon ? "weapon" : "armor",
        x:pos.x, y:pos.y,
        item: sr.pick(isWeapon ? WEAPONS : ARMORS)
      });
    }
  }
  
  return items;
}

function genChunk(seed,cx,cy){
  const sr = seededRand(hashStr(`${seed}|${cx}|${cy}`));
  const map = Array.from({length:H}, ()=>Array.from({length:W}, ()=>"#"));
  
  // Generate rooms and corridors
  const rooms = generateRooms(sr, sr.between(3,7));
  rooms.forEach(room => carveRoom(map, room));
  
  // Connect rooms
  for(let i=0; i<rooms.length-1; i++){
    const r1 = rooms[i], r2 = rooms[i+1];
    const x1 = clamp(Math.floor(r1.x + r1.w/2), 0, W-1);
    const y1 = clamp(Math.floor(r1.y + r1.h/2), 0, H-1);
    const x2 = clamp(Math.floor(r2.x + r2.w/2), 0, W-1);
    const y2 = clamp(Math.floor(r2.y + r2.h/2), 0, H-1);
    carveCorridor(map, x1,y1, x2,y2);
  }
  
  // Add some random paths for variety
  for(let i=0; i<sr.between(5,10); i++){
    const x = sr.int(W), y = sr.int(H);
    const steps = sr.between(10,30);
    let cx=x, cy=y;
    for(let s=0; s<steps; s++){
      if(cx>=0 && cx<W && cy>=0 && cy<H) map[cy][cx] = ".";
      const dir = sr.pick([[1,0],[-1,0],[0,1],[0,-1]]);
      cx = clamp(cx+dir[0],0,W-1);
      cy = clamp(cy+dir[1],0,H-1);
    }
  }
  
  ensureEdgeExits(map, sr);
  
  const biome = sr.pick(BIOMES);
  const items = placeItems(map, sr, biome);
  
  // Spawn monsters
  const monsters = [];
  const monsterCount = sr.between(8,15);
  const possibleMonsters = biome.monsters.concat(["goober","firefly"]); // Some common ones everywhere
  
  for(let i=0; i<monsterCount; i++){
    const pos = findFloorTile(map, sr);
    if(!pos) break;
    const kind = sr.pick(possibleMonsters);
    monsters.push(makeMonster(kind, pos.x, pos.y));
  }
  
  // Chance for a boss in some chunks
  if(sr.next() < 0.1){
    const pos = findFloorTile(map, sr);
    if(pos) monsters.push(makeMonster("boss", pos.x, pos.y));
  }
  
  return { map, monsters, biome:biome.id, items };
}

/* ========== Entities ========== */
function makePlayer(){ 
  return { 
    x:2, y:2, hp:20, hpMax:20, str:5, def:1, 
    level:1, xp:0, xpNext:10,
    alive:true,
    weapon:null, armor:null,
    inventory:[], potionCount:0,
    statusEffects:[], // {type, turns, value}
    turnsSinceRest:0
  }; 
}

function makeMonster(kind,x,y){
  const templates = {
    goober:{ glyph:"g", name:"candy goober", hp:6, str:3, def:0, xp:2, ai:"chase" },
    icething:{ glyph:"i", name:"ice-thing", hp:8, str:4, def:1, xp:3, ai:"chase" },
    sootling:{ glyph:"s", name:"sootling", hp:5, str:3, def:0, xp:2, ai:"wander" },
    firefly:{ glyph:"f", name:"firefly", hp:3, str:2, def:0, xp:1, ai:"skittish" },
    boss:{ glyph:"B", name:"Lich King", hp:30, str:8, def:3, xp:20, ai:"smart" }
  };
  const base = templates[kind];
  return { ...base, kind, x, y, alive:true, statusEffects:[] };
}

function levelUp(state){
  const p = state.player;
  p.level++;
  p.xpNext = p.level * 15;
  p.hpMax += 5;
  p.hp = p.hpMax;
  p.str += 2;
  p.def += 1;
  log(state, `Level up! You are now level ${p.level}!`, "xp");
  log(state, `Your stats increase! HP:${p.hpMax} STR:${p.str} DEF:${p.def}`, "good");
}

/* ========== Status Effects ========== */
function applyStatusEffect(entity, type, turns, value=0){
  if(!entity.statusEffects) entity.statusEffects = [];
  // Remove existing effect of same type
  entity.statusEffects = entity.statusEffects.filter(e => e.type !== type);
  entity.statusEffects.push({type, turns, value});
}

function processStatusEffects(state, entity, label=""){
  if(!entity.statusEffects) entity.statusEffects = [];
  const effects = entity.statusEffects;
  for(let i=effects.length-1; i>=0; i--){
    const eff = effects[i];
    
    if(eff.type === "poison"){
      entity.hp -= eff.value;
      if(label) log(state, `${label} take${label==="You"?"":"s"} ${eff.value} poison damage!`, "bad");
      if(entity.hp <= 0){
        entity.alive = false;
        if(label) log(state, `${label} succumb${label==="You"?"":"s"} to poison!`, "bad");
      }
    }
    
    eff.turns--;
    if(eff.turns <= 0) effects.splice(i, 1);
  }
}

function getStatusModifier(entity, stat){
  if(!entity.statusEffects) return 0;
  let mod = 0;
  for(const eff of entity.statusEffects){
    if(eff.type === `buff_${stat}`) mod += eff.value;
    if(eff.type === `debuff_${stat}`) mod -= eff.value;
  }
  return mod;
}

/* ========== Combat ========== */
function attack(state, attacker, defender, labelA="you", labelD=null){
  labelD = labelD || defender.name || "enemy";
  
  const aStr = attacker.str + getStatusModifier(attacker, "str");
  const dDef = defender.def + getStatusModifier(defender, "def");
  
  // Add weapon damage if player attacking
  let weaponDmg = 0;
  if(attacker === state.player && state.player.weapon){
    weaponDmg = state.player.weapon.dmg;
  }
  
  // Add armor defense if player defending
  let armorDef = 0;
  if(defender === state.player && state.player.armor){
    armorDef = state.player.armor.def;
  }
  
  const totalDef = dDef + armorDef;
  const hitRoll = roll(1,100);
  const hitChance = clamp(70 + (aStr - totalDef)*5, 30, 95);
  
  if(hitRoll > hitChance){ 
    log(state, `${labelA} miss ${labelD}.`); 
    showDamageNumber(state, defender.x, defender.y, "MISS");
    return false; 
  }
  
  const crit = Math.random() < 0.15;
  const base = roll(1, aStr) + weaponDmg - Math.floor(totalDef/2);
  const dmg = Math.max(1, base) * (crit?2:1);
  
  defender.hp -= dmg;
  
  if(crit) log(state, `${labelA} crit ${labelD} for ${dmg}!`, "good");
  else log(state, `${labelA} hit ${labelD} for ${dmg}.`);
  
  showDamageNumber(state, defender.x, defender.y, dmg.toString());
  
  if(defender.hp <= 0){ 
    defender.alive = false; 
    log(state, `${labelD} is defeated!`, "good");
    
    // Grant XP if player killed a monster
    if(attacker === state.player && defender.xp){
      state.player.xp += defender.xp;
      log(state, `+${defender.xp} XP`, "xp");
      if(state.player.xp >= state.player.xpNext){
        levelUp(state);
      }
    }
  }
  
  return true;
}

function showDamageNumber(state, x, y, text){
  const gameEl = document.getElementById("game");
  const charWidth = 8; // Approximate monospace char width
  const lineHeight = 17; // Line height from CSS
  
  const dmgEl = document.createElement("div");
  dmgEl.className = "damage-float";
  dmgEl.textContent = text;
  dmgEl.style.left = `${x * charWidth}px`;
  dmgEl.style.top = `${y * lineHeight}px`;
  
  gameEl.appendChild(dmgEl);
  setTimeout(() => dmgEl.remove(), 1000);
}

/* ========== Movement & Actions ========== */
function isBlocked(state,x,y){
  if(x<0||x>=W||y<0||y>=H) return false; // Allow edge travel
  const tile = state.chunk.map[y][x];
  if(tile === "#" || tile === "+") return true; // Walls and doors block
  if(state.player.x===x && state.player.y===y) return true;
  if(state.chunk.monsters.some(m => m.alive && m.x===x && m.y===y)) return true;
  return false;
}

function tryMove(state, dx, dy){
  if(state.over) return;
  const { player } = state;
  const nx = player.x + dx, ny = player.y + dy;
  
  // Edge travel
  if(nx < 0 || nx >= W || ny < 0 || ny >= H){
    const tcx = state.cx + (nx<0 ? -1 : nx>=W ? 1 : 0);
    const tcy = state.cy + (ny<0 ? -1 : ny>=H ? 1 : 0);
    loadOrGenChunk(state, tcx, tcy);
    player.x = (nx+W)%W;
    player.y = (ny+H)%H;
    if(state.chunk.map[player.y][player.x]==="#"){
      const spot = findOpenSpot(state.chunk.map) || {x:2,y:2};
      player.x = spot.x; player.y = spot.y;
    }
    log(state, `You step into a new area.`, "note");
    enemiesTurn(state);
    return;
  }
  
  // Check tile
  const tile = state.chunk.map[ny][nx];
  
  // Doors
  if(tile === "+"){
    state.chunk.map[ny][nx] = ".";
    log(state, "You open the door.");
    turnEnd(state);
    return;
  }
  
  // Walls
  if(tile === "#"){ 
    log(state, "You bonk the wall. It forgives you."); 
    turnEnd(state); 
    return; 
  }
  
  // Combat
  const m = state.chunk.monsters.find(mm=>mm.alive && mm.x===nx && mm.y===ny);
  if(m){ 
    attack(state, player, m, "You", m.name); 
    if(!state.over) enemiesTurn(state); 
    return; 
  }
  
  // Move
  player.x = nx; 
  player.y = ny;
  player.turnsSinceRest++;
  
  // Auto-pickup items
  interactTile(state, nx, ny);
  
  // Regen at shrines
  if(tile === "▲" && player.hp < player.hpMax && player.turnsSinceRest > 10){
    player.hp = Math.min(player.hpMax, player.hp + 2);
    player.turnsSinceRest = 0;
    log(state, "The shrine's aura heals you slightly.", "good");
  }
  
  enemiesTurn(state);
}

function interactTile(state, x, y){
  const tile = state.chunk.map[y][x];
  if(!state.chunk.items) state.chunk.items = [];
  const items = state.chunk.items;
  
  if(tile === "★"){
    log(state, choice([
      "A diary speaks: 'I dreamed I was a butterfly...'",
      "A music box plays a forgotten lullaby.",
      "An old crown whispers of lost kingdoms."
    ]), "rare");
    state.chunk.map[y][x] = ".";
    state.player.xp += 5;
    log(state, "+5 XP from artifact!", "xp");
  } else if(tile === "♪"){
    log(state, choice([
      "The floor hums with ancient magic.",
      "A voice echoes: 'Remember to be awesome.'",
      "Time feels stretchy here, like taffy."
    ]), "magic");
  } else if(tile === "$"){
    // Open chest
    const chest = items.find(i => i.type==="chest" && i.x===x && i.y===y);
    if(chest && !chest.opened){
      chest.opened = true;
      state.chunk.map[y][x] = ".";
      const loot = Math.random();
      if(loot < 0.3){
        const weapon = choice(WEAPONS);
        state.player.inventory.push({type:"weapon", item:weapon});
        log(state, `Chest contains: ${weapon.name}!`, "good");
      } else if(loot < 0.6){
        const armor = choice(ARMORS);
        state.player.inventory.push({type:"armor", item:armor});
        log(state, `Chest contains: ${armor.name}!`, "good");
      } else {
        const potion = choice(POTIONS);
        state.player.inventory.push({type:"potion", item:potion});
        state.player.potionCount++;
        log(state, `Chest contains: ${potion.name}!`, "good");
      }
    }
  } else if(tile === "!"){
    // Pickup potion
    const potion = items.find(i => i.type==="potion" && i.x===x && i.y===y);
    if(potion){
      state.player.inventory.push({type:"potion", item:potion.item});
      state.player.potionCount++;
      state.chunk.map[y][x] = ".";
      log(state, `You pickup: ${potion.item.name}`, "good");
      // Remove from items
      const idx = items.indexOf(potion);
      if(idx >= 0) items.splice(idx, 1);
    }
  } else if(tile === "/" || tile === "]"){
    // Pickup weapon/armor
    const item = items.find(i => (i.type==="weapon"||i.type==="armor") && i.x===x && i.y===y);
    if(item){
      state.player.inventory.push({type:item.type, item:item.item});
      state.chunk.map[y][x] = ".";
      log(state, `You pickup: ${item.item.name}`, "good");
      const idx = items.indexOf(item);
      if(idx >= 0) items.splice(idx, 1);
    }
  } else if(tile === "▲"){
    // Shrine interaction
    const shrine = items.find(i => i.type==="shrine" && i.x===x && i.y===y);
    if(shrine && !shrine.used){
      shrine.used = true;
      log(state, choice(QUOTES[state.chunk.biome]?.shrine || ["The shrine pulses with ancient power."]), "magic");
      // Blessing effect
      const blessing = Math.random();
      if(blessing < 0.3){
        state.player.hp = state.player.hpMax;
        log(state, "The shrine fully restores your health!", "good");
      } else if(blessing < 0.6){
        applyStatusEffect(state.player, "buff_str", 50, 3);
        log(state, "The shrine grants you strength!", "good");
      } else {
        applyStatusEffect(state.player, "buff_def", 50, 3);
        log(state, "The shrine grants you protection!", "good");
      }
    }
  }
}

function waitTurn(state){ 
  if(state.over) return; 
  log(state, "You wait. Time wiggles."); 
  state.player.turnsSinceRest = 0;
  // Small heal if hurt
  if(state.player.hp < state.player.hpMax){
    state.player.hp = Math.min(state.player.hpMax, state.player.hp + 1);
    log(state, "You catch your breath. +1 HP", "good");
  }
  enemiesTurn(state); 
}

/* ========== AI ========== */
function enemiesTurn(state){
  const mons = state.chunk.monsters;
  
  for(const m of mons){
    if(!m.alive) continue;
    
    const dx = state.player.x - m.x;
    const dy = state.player.y - m.y;
    const distance = Math.abs(dx) + Math.abs(dy);
    
    // Attack if adjacent
    if(distance === 1){
      attack(state, m, state.player, m.name, "you");
      if(state.player.hp <= 0){
        state.player.alive = false;
        state.over = true;
        log(state, "You fall. The floor hums a lullaby. Game over.", "bad");
        break;
      }
      continue;
    }
    
    // Movement AI
    let moved = false;
    if(m.ai === "chase" && distance < 8){
      // Move toward player
      const moveX = Math.sign(dx);
      const moveY = Math.sign(dy);
      
      if(moveX && !isBlocked(state, m.x+moveX, m.y)){
        m.x += moveX;
        moved = true;
      } else if(moveY && !isBlocked(state, m.x, m.y+moveY)){
        m.y += moveY;
        moved = true;
      }
    } else if(m.ai === "smart"){
      // Boss AI - smarter pathfinding
      if(distance < 10){
        const moveX = Math.sign(dx);
        const moveY = Math.sign(dy);
        
        // Try direct approach
        if(!isBlocked(state, m.x+moveX, m.y+moveY)){
          m.x += moveX;
          m.y += moveY;
        } else if(!isBlocked(state, m.x+moveX, m.y)){
          m.x += moveX;
        } else if(!isBlocked(state, m.x, m.y+moveY)){
          m.y += moveY;
        }
      }
    } else if(m.ai === "wander"){
      // Random movement
      const dir = choice([[1,0],[-1,0],[0,1],[0,-1],[0,0]]);
      if(!isBlocked(state, m.x+dir[0], m.y+dir[1])){
        m.x += dir[0];
        m.y += dir[1];
      }
    } else if(m.ai === "skittish" && distance < 5){
      // Run away
      const moveX = -Math.sign(dx);
      const moveY = -Math.sign(dy);
      
      if(!isBlocked(state, m.x+moveX, m.y+moveY)){
        m.x += moveX;
        m.y += moveY;
      }
    }
    
    // Process status effects on monster
    processStatusEffects(state, m, m.name);
  }
  
  turnEnd(state);
}

function turnEnd(state){
  // Process player status effects
  processStatusEffects(state, state.player, "You");
  
  // Time progression
  if(Math.random() < 0.1){
    state.timeIndex = (state.timeIndex + 1) % TIMES.length;
    if(Math.random() < 0.3) state.weather = choice(WEATHERS);
  }
  
  // Ambient messages
  if(Math.random() < 0.05){
    const t = TIMES[state.timeIndex];
    const w = state.weather;
    const b = state.chunk.biome;
    const quotes = ((QUOTES[b]||{})[t]||{})[w];
    if(quotes && quotes.length){
      log(state, choice(quotes), "note");
    }
  }
  
  render(state);
}

/* ========== Inventory System ========== */
function openInventory(state){
  state.ui.inventoryOpen = true;
  state.ui.selectedIndex = 0;
  renderInventory(state);
}

function closeInventory(state){
  state.ui.inventoryOpen = false;
  render(state);
}

function renderInventory(state){
  const overlay = document.getElementById("overlay");
  const content = document.getElementById("overlayContent");
  
  overlay.style.display = "flex";
  content.innerHTML = "";
  
  const items = state.player.inventory;
  if(items.length === 0){
    content.innerHTML = "<div style='color:var(--dim)'>Your inventory is empty.</div>";
    return;
  }
  
  items.forEach((item, idx) => {
    const div = document.createElement("div");
    div.className = "item";
    if(idx === state.ui.selectedIndex) div.className += " selected";
    
    let statusText = "";
    if(item.type === "weapon"){
      if(state.player.weapon === item.item) statusText = " [EQUIPPED]";
      div.innerHTML = `
        <div>
          <div class="name">/ ${item.item.name}${statusText}</div>
          <div class="desc">${item.item.desc} (DMG +${item.item.dmg})</div>
        </div>
      `;
    } else if(item.type === "armor"){
      if(state.player.armor === item.item) statusText = " [EQUIPPED]";
      div.innerHTML = `
        <div>
          <div class="name">] ${item.item.name}${statusText}</div>
          <div class="desc">${item.item.desc} (DEF +${item.item.def})</div>
        </div>
      `;
    } else if(item.type === "potion"){
      let effectText = "";
      const p = item.item;
      if(p.effect === "heal") effectText = ` (+${p.value} HP)`;
      else if(p.effect === "max_heal") effectText = " (Full heal)";
      else if(p.effect === "buff_str") effectText = ` (+${p.value} STR, ${p.turns} turns)`;
      else if(p.effect === "buff_def") effectText = ` (+${p.value} DEF, ${p.turns} turns)`;
      else if(p.effect === "buff_both") effectText = ` (+${p.value} STR/DEF, ${p.turns} turns)`;
      else if(p.effect === "berserk") effectText = ` (+${p.value} STR, -2 DEF, ${p.turns} turns)`;
      
      div.innerHTML = `
        <div>
          <div class="name">! ${item.item.name}</div>
          <div class="desc">${item.item.desc}</div>
        </div>
      `;
    }
    
    content.appendChild(div);
  });
}

function useInventoryItem(state){
  const item = state.player.inventory[state.ui.selectedIndex];
  if(!item) return;
  
  if(item.type === "weapon"){
    state.player.weapon = (state.player.weapon === item.item) ? null : item.item;
    log(state, state.player.weapon ? `Equipped ${item.item.name}!` : `Unequipped ${item.item.name}.`, "note");
  } else if(item.type === "armor"){
    state.player.armor = (state.player.armor === item.item) ? null : item.item;
    log(state, state.player.armor ? `Equipped ${item.item.name}!` : `Unequipped ${item.item.name}.`, "note");
  } else if(item.type === "potion"){
    // Use potion
    const potion = item.item;
    let used = true;
    
    if(potion.effect === "heal"){
      const prevHp = state.player.hp;
      state.player.hp = Math.min(state.player.hpMax, state.player.hp + potion.value);
      const healed = state.player.hp - prevHp;
      log(state, `You drink the ${potion.name}. Restored ${healed} HP!`, "good");
    } else if(potion.effect === "max_heal"){
      const prevHp = state.player.hp;
      state.player.hp = state.player.hpMax;
      const healed = state.player.hp - prevHp;
      log(state, `You drink the ${potion.name}. Fully restored! (+${healed} HP)`, "good");
    } else if(potion.effect === "buff_str"){
      applyStatusEffect(state.player, "buff_str", potion.turns, potion.value);
      log(state, `You drink the ${potion.name}. +${potion.value} STR for ${potion.turns} turns!`, "good");
    } else if(potion.effect === "buff_def"){
      applyStatusEffect(state.player, "buff_def", potion.turns, potion.value);
      log(state, `You drink the ${potion.name}. +${potion.value} DEF for ${potion.turns} turns!`, "good");
    } else if(potion.effect === "buff_both"){
      applyStatusEffect(state.player, "buff_str", potion.turns, potion.value);
      applyStatusEffect(state.player, "buff_def", potion.turns, potion.value);
      log(state, `You drink the ${potion.name}. +${potion.value} STR/DEF for ${potion.turns} turns!`, "good");
    } else if(potion.effect === "berserk"){
      applyStatusEffect(state.player, "buff_str", potion.turns, potion.value);
      applyStatusEffect(state.player, "debuff_def", potion.turns, 2);
      log(state, `You drink the ${potion.name}. BERSERK MODE! +${potion.value} STR, -2 DEF!`, "magic");
    } else {
      used = false;
      log(state, `The ${potion.name} has no effect right now.`, "note");
    }
    
    if(used){
      // Remove potion from inventory
      state.player.inventory.splice(state.ui.selectedIndex, 1);
      state.player.potionCount--;
      if(state.ui.selectedIndex >= state.player.inventory.length){
        state.ui.selectedIndex = Math.max(0, state.player.inventory.length - 1);
      }
    }
  }
  
  renderInventory(state);
}

function dropInventoryItem(state){
  const item = state.player.inventory[state.ui.selectedIndex];
  if(!item) return;
  
  // Ensure items array exists
  if(!state.chunk.items) state.chunk.items = [];
  
  // Unequip if equipped
  if(item.type === "weapon" && state.player.weapon === item.item){
    state.player.weapon = null;
  } else if(item.type === "armor" && state.player.armor === item.item){
    state.player.armor = null;
  }
  
  // Drop at player position
  const tile = item.type === "weapon" ? "/" : item.type === "armor" ? "]" : "!";
  if(state.chunk.map[state.player.y][state.player.x] === "."){
    state.chunk.map[state.player.y][state.player.x] = tile;
    state.chunk.items.push({
      type: item.type,
      x: state.player.x,
      y: state.player.y,
      item: item.item
    });
  }
  
  log(state, `Dropped ${item.item.name}.`, "note");
  
  // Remove from inventory
  state.player.inventory.splice(state.ui.selectedIndex, 1);
  if(item.type === "potion") state.player.potionCount--;
  
  if(state.ui.selectedIndex >= state.player.inventory.length){
    state.ui.selectedIndex = Math.max(0, state.player.inventory.length - 1);
  }
  
  renderInventory(state);
}

/* ========== World Management ========== */
function newWorld(){
  const worldSeed = Math.floor(Math.random()*2**31)>>>0;
  const player = makePlayer();
  const state = {
    worldSeed, player,
    cx:0, cy:0,
    chunk:null,
    timeIndex: rnd(TIMES.length),
    weather: choice(WEATHERS),
    log:[], over:false,
    ui:{ inventoryOpen:false, selectedIndex:0 }
  };
  
  loadOrGenChunk(state, 0, 0);
  const spot = findOpenSpot(state.chunk.map) || {x:2,y:2};
  player.x = spot.x;
  player.y = spot.y;
  
  log(state, "Welcome to the Land of Ooo! Press 'H' for help.", "note");
  log(state, "Walk off edges to explore. Press 'I' for inventory.", "note");
  
  return state;
}

function loadOrGenChunk(state, cx, cy){
  if(state.chunk) saveChunk(state.worldSeed, state.cx, state.cy, state.chunk);
  state.cx = cx;
  state.cy = cy;
  const existing = loadChunk(state.worldSeed, cx, cy);
  state.chunk = existing ? existing : genChunk(state.worldSeed, cx, cy);
  if(!state.chunk.items) state.chunk.items = [];
}

function findOpenSpot(map){
  for(let tries=0; tries<4000; tries++){
    const x = rnd(W), y = rnd(H);
    if(map[y][x] === ".") return {x,y};
  }
  return null;
}

/* ========== Rendering ========== */
function render(state){
  const { map, monsters, biome } = state.chunk;
  const buf = map.map(r => r.slice());
  
  // Draw monsters
  for(const m of monsters) if(m.alive) buf[m.y][m.x] = m.glyph;
  
  // Draw player
  if(state.player.alive) buf[state.player.y][state.player.x] = TILE.player;
  
  // Shake effect on damage
  const gameEl = document.getElementById("game");
  gameEl.textContent = buf.map(r=>r.join("")).join("\n");
  
  // Update HUD
  const p = state.player;
  setText("hp", `HP ${p.hp}/${p.hpMax}`);
  setText("xp", `XP ${p.xp}/${p.xpNext}`);
  setText("level", `Lv ${p.level}`);
  
  const strBonus = getStatusModifier(p, "str");
  const defBonus = getStatusModifier(p, "def");
  const weaponBonus = p.weapon ? p.weapon.dmg : 0;
  const armorBonus = p.armor ? p.armor.def : 0;
  
  setText("str", `STR ${p.str}${strBonus?`+${strBonus}`:""} ${weaponBonus?`[+${weaponBonus}]`:""}`);
  setText("def", `DEF ${p.def}${defBonus?`+${defBonus}`:""} ${armorBonus?`[+${armorBonus}]`:""}`);
  setText("weapon", p.weapon ? `/ ${p.weapon.name}` : "/ None");
  setText("armor", p.armor ? `] ${p.armor.name}` : "] None");
  setText("potions", `! x${p.potionCount}`);
  setText("time", `${TIMES[state.timeIndex]} / ${state.weather}`);
  setText("biome", biome.replace("_"," "));
  setText("coords", `(${state.cx},${state.cy})`);
  
  // Status effects
  const statusBar = document.getElementById("statusBar");
  statusBar.innerHTML = "";
  for(const eff of p.statusEffects){
    const div = document.createElement("div");
    div.className = `status-effect ${eff.type.startsWith("buff") ? "buff" : "debuff"}`;
    const displayName = eff.type.replace(/_/g, " ").replace("buff ", "+").replace("debuff ", "-");
    div.textContent = `${displayName} (${eff.turns})`;
    statusBar.appendChild(div);
  }
  
  // Update log
  document.getElementById("log").innerHTML = state.log.slice(-15).join("<br/>");
  
  // Show/hide restart
  document.getElementById("restart").style.display = state.over ? "inline-block" : "none";
  
  // Inventory overlay
  document.getElementById("overlay").style.display = state.ui.inventoryOpen ? "flex" : "none";
}

function setText(id, text){ 
  const el = document.getElementById(id);
  if(el) el.textContent = text; 
}

function log(state, text, cls=null){ 
  const span = cls ? `<span class="${cls}">${esc(text)}</span>` : esc(text);
  state.log.push(span);
}

/* ========== Input Handling ========== */
let STATE = newWorld();
render(STATE);

window.addEventListener("keydown", e => {
  // Inventory controls
  if(STATE.ui.inventoryOpen){
    if(e.key === "ArrowUp"){
      STATE.ui.selectedIndex = Math.max(0, STATE.ui.selectedIndex - 1);
      renderInventory(STATE);
    } else if(e.key === "ArrowDown"){
      STATE.ui.selectedIndex = Math.min(STATE.player.inventory.length - 1, STATE.ui.selectedIndex + 1);
      renderInventory(STATE);
    } else if(e.key === "Enter"){
      useInventoryItem(STATE);
    } else if(e.key.toLowerCase() === "d"){
      dropInventoryItem(STATE);
    } else if(e.key.toLowerCase() === "i" || e.key === "Escape"){
      closeInventory(STATE);
    }
    e.preventDefault();
    return;
  }
  
  // Game controls
  if(STATE.over && e.key.toLowerCase() !== "r") return;
  
  const k = e.key;
  if(k === "ArrowUp" || k === "w") { tryMove(STATE, 0, -1); e.preventDefault(); }
  else if(k === "ArrowDown" || k === "s") { tryMove(STATE, 0, 1); e.preventDefault(); }
  else if(k === "ArrowLeft" || k === "a") { tryMove(STATE, -1, 0); e.preventDefault(); }
  else if(k === "ArrowRight" || k === "d") { tryMove(STATE, 1, 0); e.preventDefault(); }
  else if(k === ".") { waitTurn(STATE); e.preventDefault(); }
  else if(k.toLowerCase() === "i") { openInventory(STATE); e.preventDefault(); }
  else if(k.toLowerCase() === "r"){
    if(STATE.chunk) saveChunk(STATE.worldSeed, STATE.cx, STATE.cy, STATE.chunk);
    STATE = newWorld();
    document.getElementById("log").innerHTML = "";
    render(STATE);
    e.preventDefault();
  }
  else if(k.toLowerCase() === "h"){
    log(STATE, "=== HELP ===", "note");
    log(STATE, "WASD/Arrows: Move | .: Wait | I: Inventory", "note");
    log(STATE, "R: New Game | Walk off edges to explore", "note");
    log(STATE, "Find weapons, armor, and potions to survive!", "note");
    log(STATE, "Defeat monsters to gain XP and level up!", "note");
    e.preventDefault();
  }
});

// Button handlers
document.getElementById("restart").addEventListener("click", () => {
  STATE = newWorld();
  document.getElementById("log").innerHTML = "";
  render(STATE);
});

document.getElementById("resetWorld").addEventListener("click", () => {
  clearWorld();
  log(STATE, "World data cleared. New areas will regenerate.", "note");
  render(STATE);
});

document.getElementById("help").addEventListener("click", () => {
  log(STATE, "=== HELP ===", "note");
  log(STATE, "WASD/Arrows: Move | .: Wait | I: Inventory", "note");
  log(STATE, "R: New Game | Walk off edges to explore", "note");
  log(STATE, "Find weapons, armor, and potions to survive!", "note");
  log(STATE, "Defeat monsters to gain XP and level up!", "note");
  render(STATE);
});
</script>
</body>
</html>